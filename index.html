<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Precise Format OCR | Avant-Garde Edition</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://unpkg.com/docx@8.5.0/build/index.umd.js"></script>
    <script src="https://unpkg.com/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <style>
        :root {
            /* Avant-Garde Palette */
            --bg-void: #050505;
            --bg-surface: #0a0a0a;
            --bg-panel: #111111;
            --bg-hover: #1a1a1a;

            --border-dim: #222;
            --border-bright: #333;

            --accent-primary: #fff;
            /* Monochrome Supremacy */
            --accent-secondary: #666;

            --text-main: #ededed;
            --text-muted: #888;
            --text-faint: #444;

            --status-success: #34d399;
            /* Emerald */
            --status-process: #fbbf24;
            /* Amber */
            --status-error: #f87171;
            /* Red */

            --font-sans: 'Inter', sans-serif;
            --font-mono: 'JetBrains Mono', monospace;

            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            scrollbar-width: thin;
            scrollbar-color: var(--border-bright) transparent;
        }

        body {
            font-family: var(--font-sans);
            background: var(--bg-void);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- Header --- */
        header {
            height: 60px;
            border-bottom: 1px solid var(--border-dim);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1.5rem;
            background: var(--bg-surface);
            z-index: 10;
        }

        .brand {
            font-weight: 700;
            font-size: 1.1rem;
            letter-spacing: -0.02em;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .brand span {
            padding: 0.2rem 0.5rem;
            background: var(--text-main);
            color: var(--bg-void);
            border-radius: var(--radius-sm);
            font-size: 0.8rem;
            font-weight: 800;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        /* --- Controls --- */
        .btn {
            background: transparent;
            border: 1px solid var(--border-bright);
            color: var(--text-main);
            padding: 0.4rem 1rem;
            border-radius: var(--radius-sm);
            cursor: pointer;
            font-size: 0.85rem;
            font-family: var(--font-mono);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover {
            background: var(--bg-hover);
            border-color: var(--text-muted);
        }

        .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--text-main);
            color: var(--bg-void);
            border-color: var(--text-main);
            font-weight: 600;
        }

        .btn-primary:hover {
            background: #ccc;
        }

        /* --- Main Layout (Split View) --- */
        .workspace {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            height: calc(100vh - 60px);
            overflow: hidden;
        }

        /* --- Left Region: Source --- */
        .region-source {
            border-right: 1px solid var(--border-dim);
            display: flex;
            flex-direction: column;
            background: var(--bg-panel);
            position: relative;
        }

        .region-toolbar {
            height: 48px;
            border-bottom: 1px solid var(--border-dim);
            display: flex;
            align-items: center;
            padding: 0 1rem;
            gap: 1rem;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .source-viewer {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            background-image: radial-gradient(var(--border-dim) 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: auto;
        }

        #sourceImage {
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            display: none;
            border-radius: var(--radius-sm);
        }

        .upload-overlay {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(10, 10, 10, 0.8);
            backdrop-filter: blur(5px);
            z-index: 5;
            transition: opacity 0.3s;
        }

        .upload-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .drop-zone {
            width: 300px;
            height: 200px;
            border: 1px dashed var(--border-bright);
            border-radius: var(--radius-lg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            background: var(--bg-surface);
            transition: all 0.2s;
            cursor: pointer;
        }

        .drop-zone:hover {
            border-color: var(--text-muted);
            transform: translateY(-2px);
        }

        /* --- Right Region: Editor --- */
        .region-editor {
            display: flex;
            flex-direction: column;
            background: var(--bg-surface);
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-dim);
            padding: 0 1rem;
            gap: 1rem;
            height: 48px;
            align-items: center;
        }

        .tab {
            padding: 0.5rem 0;
            font-size: 0.85rem;
            color: var(--text-muted);
            cursor: pointer;
            position: relative;
            transition: color 0.2s;
        }

        .tab:hover {
            color: var(--text-main);
        }

        .tab.active {
            color: var(--text-main);
            font-weight: 500;
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            width: 100%;
            height: 1px;
            background: var(--text-main);
        }

        .editor-content {
            flex: 1;
            overflow-y: auto;
            padding: 2rem;
            position: relative;
        }

        /* --- Visual Renderer Styles --- */
        .visual-doc {
            max-width: 800px;
            margin: 0 auto;
            color: var(--text-main);
            line-height: 1.6;
            font-weight: 300;
        }

        .editable-item {
            transition: all 0.2s;
            padding: 4px;
            margin: -4px;
            border-radius: 4px;
            outline: none;
        }

        .edit-mode .editable-item:hover {
            background: var(--bg-hover);
        }

        .edit-mode .editable-item:focus {
            background: var(--bg-panel);
            box-shadow: 0 0 0 1px var(--status-process);
        }

        h2 {
            font-weight: 600;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: var(--accent-primary);
            letter-spacing: -0.02em;
        }

        p {
            margin-bottom: 1rem;
            color: var(--text-main);
        }

        .subtitle {
            font-size: 0.9em;
            color: var(--text-muted);
            margin-top: -0.5rem;
            margin-bottom: 2rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
            font-size: 0.9rem;
        }

        th {
            text-align: left;
            border-bottom: 1px solid var(--border-bright);
            padding: 0.75rem;
            font-family: var(--font-mono);
            color: var(--text-muted);
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.05em;
        }

        td {
            border-bottom: 1px solid var(--border-dim);
            padding: 0.75rem;
        }

        /* --- Utility & Empty States --- */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-faint);
            font-style: italic;
        }

        .loader {
            width: 20px;
            height: 20px;
            border: 2px solid var(--border-dim);
            border-top-color: var(--text-main);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* JSON/Markdown Raw Views */
        .raw-view {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            white-space: pre-wrap;
            color: var(--text-muted);
            line-height: 1.5;
        }

        .status-badge {
            font-size: 0.75rem;
            padding: 2px 8px;
            border-radius: 12px;
            background: var(--bg-panel);
            color: var(--text-muted);
            border: 1px solid var(--border-dim);
            font-family: var(--font-mono);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--text-faint);
        }

        .status-badge.processing .status-dot {
            background: var(--status-process);
            box-shadow: 0 0 8px var(--status-process);
        }

        .status-badge.completed .status-dot {
            background: var(--status-success);
            box-shadow: 0 0 8px var(--status-success);
        }

        .status-badge.error .status-dot {
            background: var(--status-error);
        }
    </style>
</head>

<body>
    <!-- Config Hidden -->
    <input type="hidden" id="apiUrl" value="https://n8n-nick.abapi.dev/webhook">

    <header>
        <div class="brand">
            <span>OCR</span> Precise Format <small
                style="color:var(--text-faint); font-weight:400; font-family:var(--font-mono);">v3.0</small>
        </div>
        <div class="header-actions">
            <div id="statusBadge" class="status-badge">
                <div class="status-dot"></div>
                <span id="statusText">IDLE</span>
            </div>
            <button class="btn" id="editBtn" onclick="toggleEditMode()" disabled>
                ‚úèÔ∏è Edit
            </button>
            <button class="btn btn-primary" id="downloadBtn" onclick="downloadDocx()" disabled>
                Download DOCX
            </button>
        </div>
    </header>

    <div class="workspace">

        <!-- Region: Source -->
        <div class="region-source">
            <div class="region-toolbar">
                <span id="filenameDisplay">Waiting for file...</span>
            </div>
            <div class="source-viewer">
                <img id="sourceImage" src="" alt="Source Document">
                <div class="upload-overlay" id="uploadOverlay">
                    <div class="drop-zone" onclick="document.getElementById('fileInput').click()">
                        <div style="font-size: 2rem; opacity: 0.2">‚Üì</div>
                        <div style="font-size: 0.9rem;">Drop PDF/Image here</div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">(or click to browse)</div>
                    </div>
                </div>
            </div>
            <input type="file" id="fileInput" accept=".pdf,.png,.jpg,.jpeg" style="display: none;">
        </div>

        <!-- Region: Editor -->
        <div class="region-editor">
            <div class="tabs">
                <div class="tab active" data-tab="visual" onclick="switchTab('visual')">Visual</div>
                <div class="tab" data-tab="markdown" onclick="switchTab('markdown')">Markdown</div>
                <div class="tab" data-tab="json" onclick="switchTab('json')">JSON</div>
            </div>
            <div class="editor-content" id="resultContent">
                <div class="empty-state">
                    Upload a document to begin the sequence.
                </div>
            </div>
        </div>

    </div>

    <script>
        // State
        let currentResult = null; // Stores the full OCR result object
        let isEditMode = false;
        let currentTab = 'visual';
        let pollInterval = null;

        // Elements
        const fileInput = document.getElementById('fileInput');
        const uploadOverlay = document.getElementById('uploadOverlay');
        const sourceImage = document.getElementById('sourceImage');
        const resultContent = document.getElementById('resultContent');
        const statusBadge = document.getElementById('statusBadge');
        const statusText = document.getElementById('statusText');
        const filenameDisplay = document.getElementById('filenameDisplay');
        const editBtn = document.getElementById('editBtn');
        const downloadBtn = document.getElementById('downloadBtn');

        // --- Event Listeners ---
        window.addEventListener('dragover', e => e.preventDefault());
        window.addEventListener('drop', e => {
            e.preventDefault();
            if (e.dataTransfer.files.length) handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', e => {
            if (e.target.files.length) handleFiles(e.target.files);
        });

        async function handleFiles(files) {
            const file = files[0];
            if (!file) return;

            // 1. Preview Source
            filenameDisplay.textContent = file.name;
            const objectUrl = URL.createObjectURL(file);

            // Basic preview for images, simplistic placeholder for PDF (browser handles PDF if iframe, but here keeping simple img or msg)
            if (file.type.includes('pdf')) {
                sourceImage.style.display = 'none';
                // Ideally use pdf.js here, but for now we just show we have it.
                // Or maybe render the first page if we had a thumbnailer.
                // We'll trust the user sees the filename. 
                // Wait! If the user uploaded an image, show it.
            } else {
                sourceImage.src = objectUrl;
                sourceImage.style.display = 'block';
            }

            uploadOverlay.classList.add('hidden');

            // 2. Start Upload
            await startOCR(file);
        }

        // --- API Logic ---
        async function startOCR(file) {
            const apiUrl = document.getElementById('apiUrl').value;
            const formData = new FormData();
            formData.append('file0', file);

            updateStatus('UPLOADING', 'processing');

            try {
                const res = await fetch(`${apiUrl}/precise-ocr-start`, { method: 'POST', body: formData });
                const data = await res.json();

                if (data.jobId) {
                    updateStatus('PROCESSING', 'processing');
                    poll(data.jobId, apiUrl);
                } else {
                    updateStatus('ERROR: NO ID', 'error');
                }
            } catch (e) {
                updateStatus(`ERROR: ${e.message}`, 'error');
            }
        }

        function poll(jobId, apiUrl) {
            pollInterval = setInterval(async () => {
                try {
                    const res = await fetch(`${apiUrl}/precise-ocr-status?jobId=${jobId}`);
                    const data = await res.json();

                    if (data.status === 'completed') {
                        clearInterval(pollInterval);
                        updateStatus('COMPLETED', 'completed');
                        currentResult = data.result[0]; // Take first doc
                        render();
                        enableControls();
                    }
                } catch (e) {
                    console.error(e);
                }
            }, 2000);
        }

        function updateStatus(text, type) {
            statusText.textContent = text;
            statusBadge.className = `status-badge ${type}`;
        }

        function enableControls() {
            editBtn.disabled = false;
            downloadBtn.disabled = false;
        }

        // --- Rendering Logic ---
        function switchTab(tab) {
            currentTab = tab;
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`[data-tab="${tab}"]`).classList.add('active');
            render();
        }

        function render() {
            if (!currentResult) return;

            if (currentTab === 'visual') {
                renderVisual();
            } else if (currentTab === 'markdown') {
                const md = currentResult.formattedMarkdown || currentResult.rawText || '';
                resultContent.innerHTML = `<div class="raw-view">${md}</div>`;
            } else if (currentTab === 'json') {
                const json = JSON.stringify(currentResult.structuredData, null, 2);
                resultContent.innerHTML = `<div class="raw-view">${json}</div>`;
            }

            // Restore edit mode state for Visual tab
            if (currentTab === 'visual' && isEditMode) {
                resultContent.classList.add('edit-mode');
                makeEditable(true);
            } else {
                resultContent.classList.remove('edit-mode');
            }
        }

        function renderVisual() {
            const data = currentResult.structuredData || {};
            let html = '<div class="visual-doc">';

            if (data.documentTitle) {
                // data-field for direct mapping is tricky with title as it's root level
                // We'll handle root level specifically
                html += `<h1 class="editable-item" data-root-field="documentTitle">${data.documentTitle}</h1>`;
            }

            if (data.sections) {
                data.sections.forEach((section, index) => {
                    html += renderSection(section, index);
                });
            }

            html += '</div>';
            resultContent.innerHTML = html;
        }

        function renderSection(section, index) {
            // We attach data-section-index="${index}" to the parent wrapper
            // and data-sub-field="..." to specific editable parts.

            const type = section.type;
            const content = section.content;

            if (type === 'heading' || type === 'header') {
                const text = content.title || content;
                return `<h2 class="editable-item" data-section-index="${index}" data-sub-field="title">${text}</h2>`;
            }

            if (type === 'paragraph' || type === 'text') {
                const text = content.text || content;
                // Using marked.parseInline but wrapping in a span that we can edit text of
                // Note: contenteditable on HTML might break markdown structure. 
                // For simplicity/robustness, we edit the raw text.
                return `<p class="editable-item" data-section-index="${index}" data-sub-field="text">${text}</p>`;
            }

            if (type === 'table') {
                // Tables are complex. For now, let's make cells editable.
                const headers = content.headers || [];
                const rows = content.rows || [];

                let hHtml = headers.map((h, i) => `<th class="editable-item" data-section-index="${index}" data-table-type="header" data-col="${i}">${h}</th>`).join('');
                let rHtml = rows.map((row, rI) => {
                    const cells = row.map((c, cI) => `<td class="editable-item" data-section-index="${index}" data-table-type="cell" data-row="${rI}" data-col="${cI}">${c}</td>`).join('');
                    return `<tr>${cells}</tr>`;
                }).join('');

                return `<table><thead><tr>${hHtml}</tr></thead><tbody>${rHtml}</tbody></table>`;
            }

            return '';
        }

        // --- Editing Logic ---
        function toggleEditMode() {
            if (!currentResult) return;

            if (isEditMode) {
                // Saving
                saveEdits();
                isEditMode = false;
                editBtn.innerHTML = '‚úèÔ∏è Edit';
                editBtn.classList.remove('btn-primary');
                resultContent.classList.remove('edit-mode');
                makeEditable(false);
            } else {
                // Entering Edit Mode
                if (currentTab !== 'visual') switchTab('visual');
                isEditMode = true;
                editBtn.innerHTML = 'üíæ Save Changes';
                editBtn.classList.add('btn-primary');
                resultContent.classList.add('edit-mode');
                makeEditable(true);
            }
        }

        function makeEditable(enable) {
            const items = resultContent.querySelectorAll('.editable-item');
            items.forEach(el => {
                el.contentEditable = enable;
            });
        }

        function saveEdits() {
            // 1. Root fields
            const rootTitle = resultContent.querySelector('[data-root-field="documentTitle"]');
            if (rootTitle && currentResult.structuredData) {
                currentResult.structuredData.documentTitle = rootTitle.innerText;
            }

            // 2. Sections
            const items = resultContent.querySelectorAll('[data-section-index]');

            items.forEach(el => {
                const idx = parseInt(el.getAttribute('data-section-index'));
                const section = currentResult.structuredData.sections[idx];
                if (!section) return;

                const subField = el.getAttribute('data-sub-field'); // title, text
                const tableType = el.getAttribute('data-table-type'); // header, cell

                if (subField) {
                    if (typeof section.content === 'string') {
                        section.content = el.innerText;
                    } else {
                        section.content[subField] = el.innerText;
                    }
                } else if (tableType) {
                    // Handle Table Edits
                    const col = parseInt(el.getAttribute('data-col'));
                    if (tableType === 'header') {
                        section.content.headers[col] = el.innerText;
                    } else if (tableType === 'cell') {
                        const row = parseInt(el.getAttribute('data-row'));
                        section.content.rows[row][col] = el.innerText;
                    }
                }
            });

            console.log('Saved to Memory:', currentResult);
            // Flash success?
        }

        // --- Download Logic ---
        async function downloadDocx() {
            if (!currentResult) return;

            // Ensure we have the latest edits if someone clicks download while in edit mode
            if (isEditMode) saveEdits();

            const { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell } = docx;
            const data = currentResult.structuredData;

            const children = [];

            // Title
            if (data.documentTitle) {
                children.push(new Paragraph({
                    text: data.documentTitle,
                    heading: HeadingLevel.TITLE,
                    spacing: { after: 300 }
                }));
            }

            // Sections
            if (data.sections) {
                for (const section of data.sections) {
                    const content = section.content;

                    if (section.type === 'heading' || section.type === 'header') {
                        const text = content.title || content;
                        children.push(new Paragraph({
                            text: text,
                            heading: HeadingLevel.HEADING_1,
                            spacing: { before: 400, after: 200 }
                        }));
                    }

                    else if (section.type === 'paragraph' || section.type === 'text') {
                        const text = content.text || content;
                        children.push(new Paragraph({
                            text: text,
                            spacing: { after: 200 }
                        }));
                    }

                    else if (section.type === 'table') {
                        const rows = [];

                        // Header
                        if (content.headers) {
                            rows.push(new TableRow({
                                children: content.headers.map(h => new TableCell({
                                    children: [new Paragraph({ text: h, bold: true })]
                                }))
                            }));
                        }

                        // Rows
                        if (content.rows) {
                            content.rows.forEach(r => {
                                rows.push(new TableRow({
                                    children: r.map(c => new TableCell({
                                        children: [new Paragraph({ text: c })]
                                    }))
                                }));
                            });
                        }

                        children.push(new Table({ rows: rows }));
                        children.push(new Paragraph({ text: "" })); // Spacer
                    }
                }
            }

            const doc = new Document({
                sections: [{ children }]
            });

            const blob = await Packer.toBlob(doc);
            saveAs(blob, `${data.documentTitle || 'document'}.docx`);
        }

    </script>
</body>

</html>